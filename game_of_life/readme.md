# Learning TDD through Conway's Game of Life

I recently stumbled upon an excellent [article](https://towardsdatascience.com/from-scratch-the-game-of-life-161430453ee3) by Joseph Moukarzel - "From Scratch: The Game of Life", which implements Conway's particular version of cellular automata in Python and Haskell. It is a famous example of how simple rules can give rise to complex behaviors.

On the other hand, I've been thinking a lot how can **Test-Driven development** be applied in data science and started to appreciate its value, especially when going from exploration to production. By writing tests first, given the complexities associated with deploying models, a lot of stupid mistakes can be avoided and changes can be made with more confidence.

By taking the API and design described in the paper, which is sound if I am to extend the library for multiple rules (variations on the game of life), I build a Python package by writing the tests first and following the **Red, Green, Refactor pattern**. An example of the gif generated by the library with the defaults indicated in the paper:


<img src="animations/blaster_automaton.gif" width="300" height="300" align="middle">

**Figure 1:** The blaster pattern. *(Source: Joseph Moukarzel, Reproduced from code)*


I extended the library for the variation on Game of Life proposed by Conway, called [HighLife](https://www.conwaylife.com/wiki/OCA:HighLife), which was first considered by Nathan Thompson in 1994. In this configuration:

* A cell survives if has 2 or 3 neighbors
* A cell is born if it has 3 or 6 neighbors
* Dies otherwise

<img src="animations/highlife_replicator.gif" width="300" height="300" align="middle">

**Figure 1:** HighLife is well known for its replication dynamics. *(Source: Own implementation)*


### A teaching perspective
By the time this topic is to be discussed, the student already has some experience with Python, algorithm design and analysis, data structures, but not yet Object Oriented programming. It is a great way to kill a few birds with a single shot:

* Use game of life (cellular automata) to explain how it fits into the history of Cybernetics, how simple rules can give rise to complex behaviors, maps, and iteration.
* Realize that in practice we use other tools such as System Dynamics, Network analysis, Systems' Theory, Cybernetics, Game theory. Draw some connections with Turing machines and their different instantiations, topics of concerns to theoretical computer scientists. **Introduce the idea of classifying patterns** qualitatively (useful when getting to nonlinear dynamics).
* Introduce the fundamentals of Object Oriented programming and how we would go about implementing a game of life in python.
* Usage of TDD and an introduction to testing in Python. Students can have as an assignment the extension of the library to manage new rules, build an UI or explore the theoretical aspects.


Thus, it covers the **theoretical** and motivational part, **simulations** and **implementation**, but lacks connections with the real world. At this point, the idea of **agent-based modeling** can be introduced as well as a reasoning of why some system are complex and behave non-linearly (physics, meteorology, biology).

> "One interesting and surprising application of the Game of Life is
that we can construct an initial pattern that will generate the
prime numbers sequentially. The primer below is due to Dick
Hickerson, 1991" - [Melissa Gymrek, the mathematics of toys and games](http://web.mit.edu/sp.268/www/2010/lifeSlides.pdf)


### Setup and Installation

Installation in editable mode:

```bash
# if you're to play with the repository
git clone https://github.com/bizovi/cybernetics_done_right

# optional virtual environment
virtualenv venv
source venv/bin/activate

# installs the package in editable mode
cd game_of_life
pip install -e .

# check if it is installed, with dependencies
pip list | grep game
pip list | grep numpy
```

An example of usage is in the [jupyter notebook](https://github.com/Bizovi/Cybernetics_Done_Right/blob/master/game_of_life/Game_of_Life_Simulation.ipynb). The tests are written for `pytest` framework.

```bash
# install pytest if needed
pip install pytest
pip install pytest-cov

pytest  # run the test suite in /tests
pytest --cov  # test coverage report

# Tests passing
# tests/test_game_of_life.py ✓✓✓✓✓✓✓✓✓✓ (100%)

# Coverage report
# Name                         Stmts   Miss  Cover
# ------------------------------------------------
# game.py                         82     13    84%
# tests/test_game_of_life.py      73      0   100%
# ------------------------------------------------
# TOTAL                          155     13    92%
```

### Getting started: Change the code with confidence

 Let's say I want to refactor the code, and pull the `counter` calculation under `Rules` class in a function, i.e. a `@staticmethod`. Running the tests indicates that I forgot to use the `Class.my_static_method()` syntax, and after fixing the issue test suite passes, giving more confidence that previous use-cases still hold.

> The beautiful thing is, we can test the correctness of the counter functionality separately from the logic in which we implement rules. Let's do that after playing with the library for a bit.

```python
import game

SIZE = 200  # size of the grid
ITER = 1000 # number of iterations

rules = game.Rules()  # rules object
initial_state = game.State(game.board_blaster)  # predefined blaster state

game_ = game.Game(initial_state, rules, SIZE) # game object
game_states = game_.run_game(ITER) # running the game

# transform and visualize the results
res = game.results_to_array(game_states, max_size)
game.save_gif(res, filename)
```
